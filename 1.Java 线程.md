# 创建和运行线程
## 直接使用 Thread
```java
//创建线程对象
Thread t = new Thread() {
    public void run() {
        //要执行的任务
    }
};
//启动线程
t.start();
```
如
```java
//构造方法的参数是给线程指定名字
Thread t1 = new Thread( "t1") {
    @Override
    // run方法内实现了要执行的任务
    public void run( ) {
        log.debug( "hello" );
    }
};
t1.start( );
```
## 使用 Runnable 配合 Thread
把【线程】和【任务】（要执行的代码）分开

- Thread 代表线程
- Runnable 可运行的任务（线程要执行的代码）

好处：

- 方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了
- 用 Runnable 更容易与线程池等高级 API 配合
- 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活

![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635857695077-294bdab4-bae0-43d8-bbe5-c31679073bb1.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=u1c947acc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=303&originWidth=508&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27831&status=done&style=none&taskId=uf85661d7-8c51-4a2f-ade5-2fb1d72bb78&title=&width=389.99456787109375)
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635857723256-5687d454-a7f1-481d-9a95-f070df68bb28.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=248&id=u40f265e7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=379&originWidth=637&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32301&status=done&style=none&taskId=u5979dc40-f5fd-45f0-9a20-0c8f316f02e&title=&width=417.4918518066406)
Java 8 以后可以使用 lambda 精简代码
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635857742610-ae31a5b6-680a-4acb-ab16-3172bd7fe687.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=152&id=u69f4c184&margin=%5Bobject%20Object%5D&name=image.png&originHeight=215&originWidth=592&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32434&status=done&style=none&taskId=ub4f30c4c-d39d-44d7-94cc-dfe12e0515a&title=&width=417.9918518066406)
## FutureTask 配合 Thread
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635858398382-d52b33f4-e046-460e-afa1-71c02a16ae60.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=uad6c51fc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=426&originWidth=756&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58041&status=done&style=none&taskId=u7c1efb64-c63c-40fb-94d1-37d2680c352&title=&width=463.9891357421875)
## 使用线程池
后面再写


# 线程内部函数
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635859060194-21a71110-0063-4150-ab31-e4f6d0229fee.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=731&id=u51eab733&margin=%5Bobject%20Object%5D&name=image.png&originHeight=790&originWidth=927&originalType=binary&ratio=1&rotation=0&showTitle=false&size=156097&status=done&style=none&taskId=u482e9188-3567-4f87-9273-02c9804522e&title=&width=858.0054321289062)
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635859090334-7f891754-5cd3-408c-893e-ab8c8c959b0f.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=565&id=ueac263e3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=652&originWidth=923&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116143&status=done&style=none&taskId=u5f167687-ab74-4076-a2f6-48b56fbd9e3&title=&width=799.4945678710938)![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635859112344-74c5606b-587c-4e9a-b0db-f226f101ada8.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=u614189da&margin=%5Bobject%20Object%5D&name=image.png&originHeight=276&originWidth=928&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39448&status=done&style=none&taskId=u41a54d93-802c-4d5e-b5c7-e3d7b87b58d&title=&width=767.9945678710938)
## start 与 run
在main方法里调用thread.run()，程序会在main线程里执行
而在main里调用thread.start()，则会新开一个线程，在那个线程里运行thread.run()

## sleep 与 yield
### sleep
1. 调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）
2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException
3. 睡眠结束后的线程未必会立刻得到执行
4. 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性
### yield
1. 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程
2. 具体的实现依赖于操作系统的任务调度器

# 线程优先级

- 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它
- 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用

# interrupt 方法详解
## 打断 sleep，wait，join 的线程
打断 sleep 的线程, 会清空打断状态，以 sleep 为例
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635860580523-be3892d7-ad60-405f-ad0d-20703d18e8b4.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=235&id=udfc7e364&margin=%5Bobject%20Object%5D&name=image.png&originHeight=265&originWidth=619&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25388&status=done&style=none&taskId=uf0cbe25f-7c5a-4b13-a73e-ad180d2da45&title=&width=549.4972839355469)
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635860590108-22b529cb-71d2-474d-92d2-e6f3ba3a8904.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=170&id=u65ad8dba&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=712&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29638&status=done&style=none&taskId=ua2cb27e1-0380-47aa-a2c9-d3e86191ee7&title=&width=548.9918518066406)
## 打断正常运行的线程
打断正常运行的线程，并不会强行停止线程，不会清空打断状态
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635860620434-2d4c6355-7ff8-4106-a14b-efa716dddcdc.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=343&id=ucb119701&margin=%5Bobject%20Object%5D&name=image.png&originHeight=427&originWidth=682&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43956&status=done&style=none&taskId=u4208de54-f558-440d-81a5-094b0791627&title=&width=547.9918518066406)
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635860923908-cd653ff3-a063-496d-aead-bb2cdccb0bc8.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=33&id=u566aeeab&margin=%5Bobject%20Object%5D&name=image.png&originHeight=42&originWidth=558&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4308&status=done&style=none&taskId=u748f0e5c-8949-401d-87fc-c6bac6800dc&title=&width=439.99456787109375)
## 打断 park 线程
打断 park 线程, 不会清空打断状态
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635861050360-8b2c6b52-d993-4290-8a5e-f5f34a2e84de.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=323&id=uaa8c7922&margin=%5Bobject%20Object%5D&name=image.png&originHeight=365&originWidth=761&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40117&status=done&style=none&taskId=u53e437de-dfd3-42dd-8dcc-fb7c422cd8f&title=&width=672.478271484375)![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635861062393-7497d57c-3a59-482f-97a1-2460fe81c945.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=94&id=ub83a66b1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=104&originWidth=697&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10695&status=done&style=none&taskId=u85beb928-313a-41e7-ab89-fd1f4926fe4&title=&width=631.4918518066406)

**如果打断标记已经是 true, 则 park 会失效**
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635861088742-07c64120-f66e-48d1-a541-1a0204a80053.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=301&id=uccc504d8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=380&originWidth=832&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40205&status=done&style=none&taskId=u3b540d9e-1e0e-4ef4-87d5-cfe8180d27b&title=&width=657.9864501953125)
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635861112863-ccb8f561-545c-41f4-8bf5-aee9e38a894a.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=254&id=ua25c577b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=260&originWidth=663&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55606&status=done&style=none&taskId=udcdbf782-99d6-4b7b-8577-c4a852e0c24&title=&width=646.4945678710938)
**这说明：**`**park**`**仅在打断标记为false的状态下才会阻塞线程**

# JAVA线程状态
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635863385583-311faadd-b9c0-4d75-9a73-06a72f4aaaab.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=585&id=u17628b2f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=829&originWidth=1207&originalType=binary&ratio=1&rotation=0&showTitle=false&size=245808&status=done&style=none&taskId=ube3119c4-0775-4444-8c0d-58a983381ae&title=&width=852.0054321289062)
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635863083822-e39294f7-790a-46d3-87dc-f881a89cd857.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=545&id=u1d3df464&margin=%5Bobject%20Object%5D&name=image.png&originHeight=681&originWidth=949&originalType=binary&ratio=1&rotation=0&showTitle=false&size=165525&status=done&style=none&taskId=u37c85d8c-2bb6-4d13-b508-b00ec373452&title=&width=759.497314453125)

- `NEW` 线程刚被创建，但是还没有调用 `start()` 方法
- `RUNNABLE` 当调用了 `start()` 方法之后，注意，Java API 层面的 `RUNNABLE` 状态涵盖了 操作系统 层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）
- `BLOCKED` ，`WAITING` ， `TIMED_WAITING` 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述
- `TERMINATED` 当线程代码运行结束

# 主线程与守护线程
默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635863781030-b4549ea8-fef5-40ac-889b-dcd3bfcd99d9.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=423&id=u3d2d305e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=328&originWidth=341&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32279&status=done&style=none&taskId=u91d31cff-7c3a-4142-b4e5-ff01c94d888&title=&width=439.4891357421875)
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21605214/1635863792066-d5506cf6-8cd2-4498-9088-b98efb09bdf8.png#clientId=u1541a918-12ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=88&id=u1bcf581d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=100&originWidth=497&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10912&status=done&style=none&taskId=ue5fad1e0-db54-46f0-9b32-d153172b49e&title=&width=439.4918518066406)
可以看到，守护线程并没有完全运行结束，所以在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。
**注：**

- 垃圾回收器线程就是一种守护线程
- Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求


